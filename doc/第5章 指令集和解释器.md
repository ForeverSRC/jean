# 第5章 指令集和解释器

## 5.1 字节码和指令集

如果方法不是抽象的，也不是本地方法，方法的Java代码就会被编译器编译成字节码（即使方法是空的，编译器也会生成一条`return`语句），存放在`method_info`结构的`Code`属性中。

字节码中存放编码后的Java虚拟机指令。每条指令都以一个单字节的操作码（opcode）开头，这就是字节码名称的由来。

由于只使用一字节表示操作码， Java虚拟机最多只能支持256($2^{8}$)条指令。到第八版为止，Java虚拟机规范已经定义了205条指令，操作码分别是0（0x00）到202（0xCA）、254（0xFE）和255（0xFF）。这205条指令构成了Java虚拟机的指令集（instructionset)

Java虚拟机使用的是变长指令，操作码后面可以跟零字节或多字节的操作数(operand)。为了让编码后的字节码更加紧凑，很多操作码本身就隐含了操作数。

操作数栈和局部变量表只存放数据的值，并不记录数据类型。结果就是：指令必须知道自己在操作什么类型的数据。这一点直接反映在操作码的助记符上。

| 助记符首字母 | 数据类型     |
| ------------ | ------------ |
| a            | reference    |
| b            | byte/boolean |
| c            | char         |
| d            | double       |
| f            | float        |
| i            | int          |
| l            | long         |
| s            | short        |

11类指令：

1. 常量(constants)
2. 加载(load)
3. 存储(stores)
4. 操作数栈(stack)
5. 数学(math)
6. 转换(conversons)
7. 比较(comparisons)
8. 控制(control)
9. 引用(references)
10. 扩展(extended)
11. 保留(reserved)：下述指令不允许出现在class文件中
    1. `202 breakpoint`：用于调试时实现断点
    2. `254 impdep1`：内部使用
    3. `255 impdep2`：内部使用

对于`byte、char、short、boolean`类型的数据：

* 编译器在编译期或运行期将`byte`和`short`类型的数据带符号扩展为`int`类型
* 编译器在编译期或运行期将`boolean`和`char`类型数据零位扩展为相应的int类型数据

> 带符号扩展：扩展后，高位填充扩展前的符号位
>
> 无符号扩展：扩展后，高位填充0

## 5.2 指令和指令解码

Java虚拟机解释器的大致逻辑如下：

```c
do{
  atomically calculate pc and fetch opcode at pc;
  if(operands)
    fetch operands;
  execute the action for the opcode;
}while(there is no more to do);
```

简单表示即为：计算pc、指令解码、指令执行。

## 5.3 常量指令

常量指令把常量推入操作数栈顶。常量可以来自三个地方：

1. 隐含在操作码里
2. 操作数
3. 运行时常量池

## 5.4 加载指令

加载指令从局部变量表获取变量，然后推入操作数栈顶。

加载指令共33条，按照所操作变量类型可分为6类：

* `aload`
* `dload`
* `fload`
* `iload`
* `lload`
* `xaload`：操作数组

## 5.5 存储指令

存储指令把变量从操作数栈顶弹出，然后存入局部变量表。和加载指令一样，存储指令也可以分为6类。

## 5.6 栈指令

栈指令直接对操作数栈进行操作，共9条：pop和pop2指令将栈顶变量弹出，dup系列指令复制栈顶变量，swap指令交换栈顶的两个变量。栈指令并不关心变量类型。

### 1.pop和pop2

pop指令用于弹出只占一个操作数栈位置的变量，如int、float。

pop2指令用于弹出占两个操作数栈位置的变量，如double、long

### 2.dup

dup指令复制栈顶的单个变量。

dup2指令复制栈顶的前两个变量。

**带x的指令是复制栈顶数据并插入栈顶以下的某个位置**。共有4个指令, dup_x1， dup2_x1,dup_x2，dup2_x2.对于带x的复制插入指令，只要将指令的dup和x的系数相加，结果即为需要插入的位置。因此：

* dup_x1插入位置:1+1=2，即栈顶2个Slot下面
* dup_x2插入位置:1+2=3，即栈顶3个S1ot下面
* dup2_x1插入位置:2+1=3，即栈顶3个S1ot下面
* dup2_×2插入位置:2+2=4，即栈顶4个Slot下面

### 3.swap

swap指令交换栈顶两个变量

## 5.7 数学指令

数学指令大致对应Java语言中的加、减、乘、除等数学运算符。数学指令包括算术指令、位移指令和布尔运算指令等，共37条。

### 5.7.1 算术指令

* 加法（add）
  * 操作数栈顶两对应类型变量相加
* 减法（sub）
  * 操作数栈顶两对应类型变量相减
* 乘法（mul）
  * 操作数栈顶两对应类型变量相乘
* 除法（div）
  * 操作数栈顶两对应类型变量相除
  * 注意除零异常
* 求余（rem）
  * 操作数栈顶两对应类型变量求余数
  * 注意除零异常
* 取反（neg）
  * 操作数栈顶元素变为其负数

> Go语言没有给浮点数类型定义求余操作符，所以需要使用math包的Mod()函数。另外，浮点数类型因为有Infinity（无穷大）值，所以即使是除零，也不会导致ArithmeticException异常抛出。

### 5.7.2 移位指令

* 左移
  * 算术（有符号）左移
  * 逻辑（无符号）左移
* 右移
  * 算术（有符号）右移
  * 逻辑（无符号）右移

> **算术左移-逻辑左移**
>
> 算术左移和逻辑左移都是右边补0： 比如 00101011 
>
> 算术左移一位:01010110 
>
> 逻辑左移一位:01010110 
>
> 
>
> **算术右移，逻辑右移**
>
> 逻辑右移将二进制数整体右移，左边补0即可 
>
> 如10101101逻辑右移一位为01010110 
>
> 算术右移符号位要一起移动，并且在左边补上符号位，也就是如果符号位是1就补1符号位是0就补0 
>
> 比如：11100算术右移一位为11110（符号位1跟着一起移动并且左边补了1） 



操作数栈顶元素表示要移动多少位，是一个int，紧跟着栈顶元素的下一个元素表示要进行移位操作的变量。

两个操作数均需要弹出，将移位结果存入操作数栈。

### 5.7.3 位运算指令

只能操作int和long变量，分为：

* 按位与（and）
* 按位或（or）
* 按位异或（xor）

指令将操作数栈顶的两个元素弹出，将弹出的第二个元素与弹出的第一个元素进行位运算，将结果压入操作数栈

### 5.7.4 iinc指令

给局部变量表中的int变量增加常量值，局部变量表索引和常量值都由指令的操作数提供

## 5.8 类型转换指令

大致对应Java中基本类型的强制转换。将操作数栈栈顶元素弹出，转换为对应类型后再压入操作数栈。

按照被转换变量的类型，类型转换指令可以分为4种：

* `i2x`系列指令把`int`变量强制转换成其他类型
* `l2x`系列指令把`long`变量强制转换成其他类型
* `f2x`系列指令把`float`变量强制转换成其他类型
* `d2x`系列指令把`double`变量强制转换成其他类型

## 5.9 比较指令

比较指令可以分为两类：

1. 将比较结果推入操作数栈顶
   1. 将栈顶两个操作数v2，v1依次弹出，比较v1和v2的大小关系，将比较结果压入操作数栈
   2. java中比较结果一般用`1,0,-1`依次表示大于、等于、小于
2. 根据比较结果跳转

比较指令是编译器实现`if-else、for、while`等语句的基石。

### 5.9.1 lcmp指令

用于比较`long`类型

### 5.9.2 fcmp\<op>和dcmp\<op>指令

`fcmpg`和`fcmpl`指令用于比较float变量

由于浮点数计算有可能产生`NaN`（Not a Number）值，所以比较两个浮点数时，除了大于、等于、小于之外，还有第4种结果：无法比较。`fcmpg`和`fcmpl`指令的区别就在于对第4种结果的定义。

当两个`float`变量中至少有一个是`NaN`时，用`fcmpg`指令比较的结果是`1`，而用`fcmpl`指令比较的结果是`-1`

`dcmpg`和`dcmpl`指令用来比较`double`变量，逻辑和`fcmpg`和`fcmpl`指令一致。

### 5.9.3 if\<cond>指令

`if<cond>`指令把操作数栈顶的int变量弹出，然后跟0进行比较，满足条件则跳转，跳转的PC位置由指令后的操作数指定。

### 5.9.4 if_icmp\<cond>指令

`if_icmp<cond>`指令把栈顶的两个int变量弹出，然后进行比较，满足条件则跳转，跳转的PC位置由指令后的操作数指定。

### 5.9.5 if_acmp\<cond>指令

`if_acmpeq`和`if_acmpne`指令把栈顶的两个引用弹出，根据引用是否相同进行跳转。

## 5.10 控制指令

### 5.10.1 goto指令

进行无条件跳转，跳转的pc由指令后的操作数指定。

### 5.10.2 tableswitch指令

Java语言中的`switch-case`语句有两种实现方式：如果case值可以编码成一个索引表，则实现成`tableswitch`指令；否则实现成`lookupswitch`指令

`tableswitch`指令操作码的后面有0～3字节的padding，以保证`defaultOffset`在字节码中的地址是4的倍数。

`defaultOffset`对应默认情况下执行跳转所需的字节码偏移量；`low`和`high`记录`case`的取值范围；`jumpOffsets`是一个索引表，里面存放`high-low+1`个`int`值，对应各种`case`情况下，执行跳转所需的字节码偏移量。

命令执行时先从操作数栈中弹出一个`int`变量，然后看它是否在`low`和`high`给定的范围之内。如果在，则从`jumpOffsets`表中查出偏移量进行跳转，否则按照`defaultOffset`跳转。

### 5.10.3 lookupswitch指令

读取操作数时，也需要先调过padding。

需要读取的操作数有：

* defaultOffset：默认跳转位置
* npairs
* matchOffsets

`matchOffsets`有点像Map，它的key是case值，value是跳转偏移量。执行时，先从操作数栈中弹出一个int变量，然后用它查找matchOffsets，看是否能找到匹配的key。如果能，则按照value给出的偏移量跳转，否则按照defaultOffset跳转

## 5.11 扩展指令

### 5.11.1 wide指令

加载类指令、存储类指令、ret指令和iinc指令需要按索引访问局部变量表，索引以uint8的形式存在字节码中。对于大部分方法来说，局部变量表大小都不会超过256，所以用一字节来表示索引就够了。但是如果有方法的局部变量表超过这限制呢？Java虚拟机规范定义了wide指令来扩展前述指令。

### 5.11.2 ifnull指令和ifnonnull指令

根据引用是否是null进行跳转，ifnull和ifnonnull指令把栈顶的引用弹出。

### 5.11.3 goto_w指令

goto_w指令和goto指令的唯一区别就是索引从2字节变成了4字节。

## 5.12 解释器

